   1               		.file	"LCDmodule.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  15               	.global	LCD_SetMarker
  17               	LCD_SetMarker:
   1:src/LCDmodule.c **** /* File LCDmodule.c:  Functions for LCD module interface.
   2:src/LCDmodule.c **** User must define _LCDport in LCDmodule.h header file and set all of the
   3:src/LCDmodule.c **** port pins for output before calling any of the LCD module functions.
   4:src/LCDmodule.c **** See LCDmodule.h for information on port connections to the LCD module.
   5:src/LCDmodule.c **** */
   6:src/LCDmodule.c **** 
   7:src/LCDmodule.c **** #include <avr/io.h>
   8:src/LCDmodule.c **** #include <util/delay.h>
   9:src/LCDmodule.c **** #include "LCDmodule.h"
  10:src/LCDmodule.c **** 
  11:src/LCDmodule.c **** // The MSB of _LCDport is used as a marker for monitoring signals on a scope.
  12:src/LCDmodule.c **** // LCD_MarkBit is the global variable used to enable the marker output.
  13:src/LCDmodule.c **** unsigned char LCD_MarkBit = 0x00;
  14:src/LCDmodule.c **** void LCD_SetMarker(unsigned char MarkerEn)
  15:src/LCDmodule.c **** // Enables MSB of _LCDport as marker bit when MarkerEn is not 0.
  16:src/LCDmodule.c **** {
  19               	.LM0:
  20               	.LFBB1:
  21               	/* prologue: function */
  22               	/* frame size = 0 */
  23               	/* stack size = 0 */
  24               	.L__stack_usage = 0
  17:src/LCDmodule.c ****   if (MarkerEn)
  26               	.LM1:
  27 0000 91E0      		ldi r25,lo8(1)
  28 0002 8111      		cpse r24,__zero_reg__
  29 0004 00C0      		rjmp .L2
  30 0006 90E0      		ldi r25,0
  31               	.L2:
  32 0008 9795      		ror r25
  33 000a 9927      		clr r25
  34 000c 9795      		ror r25
  18:src/LCDmodule.c ****     LCD_MarkBit = 0x80;
  19:src/LCDmodule.c ****   else
  20:src/LCDmodule.c ****     LCD_MarkBit = 0x00;
  36               	.LM2:
  37 000e 9093 0000 		sts LCD_MarkBit,r25
  38               	/* epilogue start */
  21:src/LCDmodule.c ****   return;
  22:src/LCDmodule.c **** }
  40               	.LM3:
  41 0012 0895      		ret
  43               	.Lscope1:
  47               	.global	LCD_WriteInst
  49               	LCD_WriteInst:
  23:src/LCDmodule.c **** 
  24:src/LCDmodule.c **** void LCD_Init(void)
  25:src/LCDmodule.c **** /* Initialize the LCD display for 4-bit parallel data interface. */
  26:src/LCDmodule.c **** {
  27:src/LCDmodule.c **** // Set 4-bit parallel interface with the LCD controller
  28:src/LCDmodule.c ****   _LCDport = LCD_MarkBit | _LCDinitCom;
  29:src/LCDmodule.c ****   _LCDport = LCD_MarkBit | _LCDinitCom;
  30:src/LCDmodule.c ****   _LCDport = LCD_MarkBit | 0x40 | _LCDinitCom;  // Set Enable
  31:src/LCDmodule.c ****   _LCDport = LCD_MarkBit | 0x40 | _LCDinitCom;
  32:src/LCDmodule.c ****   _LCDport = LCD_MarkBit | _LCDinitCom;         // Clear Enable
  33:src/LCDmodule.c ****   _LCDport = LCD_MarkBit | _LCDinitCom;
  34:src/LCDmodule.c ****   _LCDport = 0x00;  // clear port output
  35:src/LCDmodule.c ****   _delay_us(50);
  36:src/LCDmodule.c **** // Set function (001N LFxx): N=0=> 4-bit data, L=1=> 2 display lines,
  37:src/LCDmodule.c **** // F=0=> 5x8 dot characters
  38:src/LCDmodule.c ****   LCD_WriteInst(0x28);
  39:src/LCDmodule.c **** // Set function again (required for PCM1602B):
  40:src/LCDmodule.c **** //  LCD_WriteInst(0x28);
  41:src/LCDmodule.c **** // Set entry mode (0000 01MS): M=1=> increment cursor address (move right),
  42:src/LCDmodule.c **** // S=0=> no display shift
  43:src/LCDmodule.c ****   LCD_WriteInst(0x06);
  44:src/LCDmodule.c **** // ON/OFF control (0000 1DCB): Display ON, cursor OFF, cursor blink OFF:
  45:src/LCDmodule.c ****   LCD_WriteInst(0x0C);
  46:src/LCDmodule.c **** // Clear display and move cursor home:
  47:src/LCDmodule.c ****   LCD_Clear();
  48:src/LCDmodule.c ****   return;
  49:src/LCDmodule.c **** }
  50:src/LCDmodule.c **** 
  51:src/LCDmodule.c **** void LCD_WriteInst(unsigned char WriteByte)
  52:src/LCDmodule.c **** /* When 4-bit interface is used, MSBs of the instruction/data bytes are sent
  53:src/LCDmodule.c ****    first. Port output is set twice to satisfy the LCD controller timing.
  54:src/LCDmodule.c ****    The 40 us delay at the end is the minimum time required by the LCD module
  55:src/LCDmodule.c ****    to complete the internal operations after receiving the instructions.
  56:src/LCDmodule.c ****    Note that, clear display and return home instructions take an additional
  57:src/LCDmodule.c ****    1.5ms to execute. This additional delay must be provided in the caller.
  58:src/LCDmodule.c **** */
  59:src/LCDmodule.c **** {
  51               	.LM4:
  52               	.LFBB2:
  53               	/* prologue: function */
  54               	/* frame size = 0 */
  55               	/* stack size = 0 */
  56               	.L__stack_usage = 0
  60:src/LCDmodule.c ****   unsigned char  MSnibble, LSnibble;
  61:src/LCDmodule.c **** 
  62:src/LCDmodule.c ****   MSnibble = WriteByte >> 4;
  58               	.LM5:
  59 0014 982F      		mov r25,r24
  60 0016 9295      		swap r25
  61 0018 9F70      		andi r25,lo8(15)
  63:src/LCDmodule.c ****   LSnibble = WriteByte & 0x0F;
  63               	.LM6:
  64 001a 8F70      		andi r24,lo8(15)
  64:src/LCDmodule.c ****   if (LCD_MarkBit)
  66               	.LM7:
  67 001c 2091 0000 		lds r18,LCD_MarkBit
  68 0020 2223      		tst r18
  69 0022 01F0      		breq .L4
  65:src/LCDmodule.c ****   { MSnibble |= 0x80;
  71               	.LM8:
  72 0024 9068      		ori r25,lo8(-128)
  66:src/LCDmodule.c ****     LSnibble |= 0x80;
  74               	.LM9:
  75 0026 8068      		ori r24,lo8(-128)
  76               	.L4:
  67:src/LCDmodule.c ****   }
  68:src/LCDmodule.c ****   _LCDport = MSnibble;
  78               	.LM10:
  79 0028 95B9      		out 0x5,r25
  69:src/LCDmodule.c ****   _LCDport = MSnibble;
  81               	.LM11:
  82 002a 95B9      		out 0x5,r25
  70:src/LCDmodule.c **** //  _delay_us(1);
  71:src/LCDmodule.c ****   _LCDport = 0x40 | MSnibble;  // Set Enable
  84               	.LM12:
  85 002c 292F      		mov r18,r25
  86 002e 2064      		ori r18,lo8(64)
  87 0030 25B9      		out 0x5,r18
  72:src/LCDmodule.c ****   _LCDport = 0x40 | MSnibble;
  89               	.LM13:
  90 0032 25B9      		out 0x5,r18
  73:src/LCDmodule.c ****   _LCDport = MSnibble;         // Clear Enable
  92               	.LM14:
  93 0034 95B9      		out 0x5,r25
  74:src/LCDmodule.c ****   _LCDport = MSnibble;
  95               	.LM15:
  96 0036 95B9      		out 0x5,r25
  75:src/LCDmodule.c ****   _LCDport = LSnibble;
  98               	.LM16:
  99 0038 85B9      		out 0x5,r24
  76:src/LCDmodule.c ****   _LCDport = LSnibble;
 101               	.LM17:
 102 003a 85B9      		out 0x5,r24
  77:src/LCDmodule.c ****   _LCDport = 0x40 | LSnibble;  // Set Enable
 104               	.LM18:
 105 003c 982F      		mov r25,r24
 106 003e 9064      		ori r25,lo8(64)
 107 0040 95B9      		out 0x5,r25
  78:src/LCDmodule.c ****   _LCDport = 0x40 | LSnibble;
 109               	.LM19:
 110 0042 95B9      		out 0x5,r25
  79:src/LCDmodule.c ****   _LCDport = LSnibble;         // Clear Enable
 112               	.LM20:
 113 0044 85B9      		out 0x5,r24
  80:src/LCDmodule.c ****   _LCDport = LSnibble;
 115               	.LM21:
 116 0046 85B9      		out 0x5,r24
  81:src/LCDmodule.c ****   _LCDport = 0x00;  // clear port output
 118               	.LM22:
 119 0048 15B8      		out 0x5,__zero_reg__
 120               	.LBB12:
 121               	.LBB13:
 123               	.Ltext1:
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 125               	.LM23:
 126 004a 8AE6      		ldi r24,lo8(106)
 127 004c 8A95      	1:	dec r24
 128 004e 01F4      		brne 1b
 129 0050 00C0      		rjmp .
 130               	/* epilogue start */
 131               	.LBE13:
 132               	.LBE12:
 134               	.Ltext2:
  82:src/LCDmodule.c ****   _delay_us(40);
  83:src/LCDmodule.c ****   return;
  84:src/LCDmodule.c **** }
 136               	.LM24:
 137 0052 0895      		ret
 143               	.Lscope2:
 146               	.global	LCD_WriteData
 148               	LCD_WriteData:
  85:src/LCDmodule.c **** 
  86:src/LCDmodule.c **** void LCD_WriteData(unsigned char WriteByte)
  87:src/LCDmodule.c **** /* When 4-bit interface is used, MSBs of the instruction/data bytes are sent
  88:src/LCDmodule.c ****    first. Port output is set twice to satisfy the LCD controller timing.
  89:src/LCDmodule.c ****    The 50 us delay at the end is required by the LCD module to complete the
  90:src/LCDmodule.c ****    internal operations after receiving the data.
  91:src/LCDmodule.c **** */
  92:src/LCDmodule.c **** {
 150               	.LM25:
 151               	.LFBB3:
 152               	/* prologue: function */
 153               	/* frame size = 0 */
 154               	/* stack size = 0 */
 155               	.L__stack_usage = 0
  93:src/LCDmodule.c ****   unsigned char  MSnibble, LSnibble;
  94:src/LCDmodule.c **** 
  95:src/LCDmodule.c **** // Set the register select bit, RS=1, when sending display data to LCD:
  96:src/LCDmodule.c ****   MSnibble = 0x10 | (WriteByte >> 4);
 157               	.LM26:
 158 0054 982F      		mov r25,r24
 159 0056 9295      		swap r25
 160 0058 9F70      		andi r25,lo8(15)
  97:src/LCDmodule.c ****   LSnibble = 0x10 | (WriteByte & 0x0F);
 162               	.LM27:
 163 005a 8F70      		andi r24,lo8(15)
 165               	.LM28:
 166 005c 282F      		mov r18,r24
 167 005e 2061      		ori r18,lo8(16)
  98:src/LCDmodule.c ****   if (LCD_MarkBit)
 169               	.LM29:
 170 0060 3091 0000 		lds r19,LCD_MarkBit
 171 0064 3111      		cpse r19,__zero_reg__
 172 0066 00C0      		rjmp .L9
  96:src/LCDmodule.c ****   LSnibble = 0x10 | (WriteByte & 0x0F);
 174               	.LM30:
 175 0068 9061      		ori r25,lo8(16)
 176               	.L10:
  99:src/LCDmodule.c ****   { MSnibble |= 0x80;
 100:src/LCDmodule.c ****     LSnibble |= 0x80;
 101:src/LCDmodule.c ****   }
 102:src/LCDmodule.c **** // Write 4 MSBs:
 103:src/LCDmodule.c ****   _LCDport = MSnibble;
 178               	.LM31:
 179 006a 95B9      		out 0x5,r25
 104:src/LCDmodule.c ****   _LCDport = MSnibble;
 181               	.LM32:
 182 006c 95B9      		out 0x5,r25
 105:src/LCDmodule.c ****   _LCDport = 0x40 | MSnibble;  // Set Enable
 184               	.LM33:
 185 006e 892F      		mov r24,r25
 186 0070 8064      		ori r24,lo8(64)
 187 0072 85B9      		out 0x5,r24
 106:src/LCDmodule.c ****   _LCDport = 0x40 | MSnibble;
 189               	.LM34:
 190 0074 85B9      		out 0x5,r24
 107:src/LCDmodule.c ****   _LCDport = MSnibble;         // Clear Enable
 192               	.LM35:
 193 0076 95B9      		out 0x5,r25
 108:src/LCDmodule.c ****   _LCDport = MSnibble;
 195               	.LM36:
 196 0078 95B9      		out 0x5,r25
 109:src/LCDmodule.c **** // Write 4 LSBs:
 110:src/LCDmodule.c ****   _LCDport = LSnibble;
 198               	.LM37:
 199 007a 25B9      		out 0x5,r18
 111:src/LCDmodule.c ****   _LCDport = LSnibble;
 201               	.LM38:
 202 007c 25B9      		out 0x5,r18
 112:src/LCDmodule.c ****   _LCDport = 0x40 | LSnibble;  // Set Enable
 204               	.LM39:
 205 007e 822F      		mov r24,r18
 206 0080 8064      		ori r24,lo8(64)
 207 0082 85B9      		out 0x5,r24
 113:src/LCDmodule.c ****   _LCDport = 0x40 | LSnibble;
 209               	.LM40:
 210 0084 85B9      		out 0x5,r24
 114:src/LCDmodule.c ****   _LCDport = LSnibble;         // Clear Enable
 212               	.LM41:
 213 0086 25B9      		out 0x5,r18
 115:src/LCDmodule.c ****   _LCDport = LSnibble;
 215               	.LM42:
 216 0088 25B9      		out 0x5,r18
 116:src/LCDmodule.c ****   _LCDport = 0x00;  // clear port output
 218               	.LM43:
 219 008a 15B8      		out 0x5,__zero_reg__
 220               	.LBB14:
 221               	.LBB15:
 223               	.Ltext3:
 225               	.LM44:
 226 008c 85E8      		ldi r24,lo8(-123)
 227 008e 8A95      	1:	dec r24
 228 0090 01F4      		brne 1b
 229 0092 0000      		nop
 230               	/* epilogue start */
 231               	.LBE15:
 232               	.LBE14:
 234               	.Ltext4:
 117:src/LCDmodule.c ****   _delay_us(50);
 118:src/LCDmodule.c ****   return;
 119:src/LCDmodule.c **** }
 236               	.LM45:
 237 0094 0895      		ret
 238               	.L9:
  99:src/LCDmodule.c ****     LSnibble |= 0x80;
 240               	.LM46:
 241 0096 9069      		ori r25,lo8(-112)
 100:src/LCDmodule.c ****   }
 243               	.LM47:
 244 0098 282F      		mov r18,r24
 245 009a 2069      		ori r18,lo8(-112)
 246 009c 00C0      		rjmp .L10
 252               	.Lscope3:
 254               	.global	LCD_Clear
 256               	LCD_Clear:
 120:src/LCDmodule.c **** 
 121:src/LCDmodule.c **** void LCD_Clear(void)
 122:src/LCDmodule.c **** /* Clears display and resets cursor position. */
 123:src/LCDmodule.c **** {
 258               	.LM48:
 259               	.LFBB4:
 260               	/* prologue: function */
 261               	/* frame size = 0 */
 262               	/* stack size = 0 */
 263               	.L__stack_usage = 0
 124:src/LCDmodule.c **** // Clear display (0000 0001):
 125:src/LCDmodule.c ****   LCD_WriteInst(0x01);
 265               	.LM49:
 266 009e 81E0      		ldi r24,lo8(1)
 267 00a0 0E94 0000 		call LCD_WriteInst
 268               	.LBB16:
 269               	.LBB17:
 271               	.Ltext5:
 187:/usr/avr/include/util/delay.h **** 
 273               	.LM50:
 274 00a4 8FE9      		ldi r24,lo8(3999)
 275 00a6 9FE0      		ldi r25,hi8(3999)
 276 00a8 0197      	1:	sbiw r24,1
 277 00aa 01F4      		brne 1b
 278 00ac 00C0      		rjmp .
 279 00ae 0000      		nop
 280               	.LBE17:
 281               	.LBE16:
 283               	.Ltext6:
 126:src/LCDmodule.c ****   _delay_ms(2);
 127:src/LCDmodule.c **** // Return home (0000 001x):
 128:src/LCDmodule.c ****   LCD_WriteInst(0x02);
 285               	.LM51:
 286 00b0 82E0      		ldi r24,lo8(2)
 287 00b2 0E94 0000 		call LCD_WriteInst
 288               	.LBB18:
 289               	.LBB19:
 291               	.Ltext7:
 187:/usr/avr/include/util/delay.h **** 
 293               	.LM52:
 294 00b6 8FE9      		ldi r24,lo8(3999)
 295 00b8 9FE0      		ldi r25,hi8(3999)
 296 00ba 0197      	1:	sbiw r24,1
 297 00bc 01F4      		brne 1b
 298 00be 00C0      		rjmp .
 299 00c0 0000      		nop
 300               	/* epilogue start */
 301               	.LBE19:
 302               	.LBE18:
 304               	.Ltext8:
 129:src/LCDmodule.c ****   _delay_ms(2);
 130:src/LCDmodule.c ****   return;
 131:src/LCDmodule.c **** }
 306               	.LM53:
 307 00c2 0895      		ret
 309               	.Lscope4:
 311               	.global	LCD_Init
 313               	LCD_Init:
  26:src/LCDmodule.c **** // Set 4-bit parallel interface with the LCD controller
 315               	.LM54:
 316               	.LFBB5:
 317               	/* prologue: function */
 318               	/* frame size = 0 */
 319               	/* stack size = 0 */
 320               	.L__stack_usage = 0
  28:src/LCDmodule.c ****   _LCDport = LCD_MarkBit | _LCDinitCom;
 322               	.LM55:
 323 00c4 8091 0000 		lds r24,LCD_MarkBit
 324 00c8 8260      		ori r24,lo8(2)
 325 00ca 85B9      		out 0x5,r24
  29:src/LCDmodule.c ****   _LCDport = LCD_MarkBit | 0x40 | _LCDinitCom;  // Set Enable
 327               	.LM56:
 328 00cc 8091 0000 		lds r24,LCD_MarkBit
 329 00d0 8260      		ori r24,lo8(2)
 330 00d2 85B9      		out 0x5,r24
  30:src/LCDmodule.c ****   _LCDport = LCD_MarkBit | 0x40 | _LCDinitCom;
 332               	.LM57:
 333 00d4 8091 0000 		lds r24,LCD_MarkBit
 334 00d8 8264      		ori r24,lo8(66)
 335 00da 85B9      		out 0x5,r24
  31:src/LCDmodule.c ****   _LCDport = LCD_MarkBit | _LCDinitCom;         // Clear Enable
 337               	.LM58:
 338 00dc 8091 0000 		lds r24,LCD_MarkBit
 339 00e0 8264      		ori r24,lo8(66)
 340 00e2 85B9      		out 0x5,r24
  32:src/LCDmodule.c ****   _LCDport = LCD_MarkBit | _LCDinitCom;
 342               	.LM59:
 343 00e4 8091 0000 		lds r24,LCD_MarkBit
 344 00e8 8260      		ori r24,lo8(2)
 345 00ea 85B9      		out 0x5,r24
  33:src/LCDmodule.c ****   _LCDport = 0x00;  // clear port output
 347               	.LM60:
 348 00ec 8091 0000 		lds r24,LCD_MarkBit
 349 00f0 8260      		ori r24,lo8(2)
 350 00f2 85B9      		out 0x5,r24
  34:src/LCDmodule.c ****   _delay_us(50);
 352               	.LM61:
 353 00f4 15B8      		out 0x5,__zero_reg__
 354               	.LBB20:
 355               	.LBB21:
 357               	.Ltext9:
 359               	.LM62:
 360 00f6 85E8      		ldi r24,lo8(-123)
 361 00f8 8A95      	1:	dec r24
 362 00fa 01F4      		brne 1b
 363 00fc 0000      		nop
 364               	.LBE21:
 365               	.LBE20:
 367               	.Ltext10:
  38:src/LCDmodule.c **** // Set function again (required for PCM1602B):
 369               	.LM63:
 370 00fe 88E2      		ldi r24,lo8(40)
 371 0100 0E94 0000 		call LCD_WriteInst
  43:src/LCDmodule.c **** // ON/OFF control (0000 1DCB): Display ON, cursor OFF, cursor blink OFF:
 373               	.LM64:
 374 0104 86E0      		ldi r24,lo8(6)
 375 0106 0E94 0000 		call LCD_WriteInst
  45:src/LCDmodule.c **** // Clear display and move cursor home:
 377               	.LM65:
 378 010a 8CE0      		ldi r24,lo8(12)
 379 010c 0E94 0000 		call LCD_WriteInst
  47:src/LCDmodule.c ****   return;
 381               	.LM66:
 382 0110 0C94 0000 		jmp LCD_Clear
 384               	.Lscope5:
 388               	.global	LCD_MoveCursor
 390               	LCD_MoveCursor:
 132:src/LCDmodule.c **** 
 133:src/LCDmodule.c **** void LCD_MoveCursor(unsigned char Line,
 134:src/LCDmodule.c ****                     unsigned char Column)
 135:src/LCDmodule.c **** /* Sets cursor position as specified by Line and Column:
 136:src/LCDmodule.c ****    Line=1=> first line,  Column=1=> first character on the left */
 137:src/LCDmodule.c **** {
 392               	.LM67:
 393               	.LFBB6:
 394               	/* prologue: function */
 395               	/* frame size = 0 */
 396               	/* stack size = 0 */
 397               	.L__stack_usage = 0
 138:src/LCDmodule.c ****   unsigned char  InstByte;
 139:src/LCDmodule.c **** 
 140:src/LCDmodule.c ****   if (Line == 1)
 399               	.LM68:
 400 0114 8130      		cpi r24,lo8(1)
 401 0116 01F0      		breq .L15
 141:src/LCDmodule.c ****     InstByte = 0x80;
 142:src/LCDmodule.c ****   else
 143:src/LCDmodule.c ****     InstByte = 0xC0;
 403               	.LM69:
 404 0118 80EC      		ldi r24,lo8(-64)
 405               	.L14:
 144:src/LCDmodule.c ****   InstByte |= (Column - 1) & 0x0F;
 407               	.LM70:
 408 011a 6150      		subi r22,lo8(-(-1))
 410               	.LM71:
 411 011c 6F70      		andi r22,lo8(15)
 145:src/LCDmodule.c ****   LCD_WriteInst(InstByte);
 413               	.LM72:
 414 011e 862B      		or r24,r22
 415 0120 0C94 0000 		jmp LCD_WriteInst
 416               	.L15:
 141:src/LCDmodule.c ****     InstByte = 0x80;
 418               	.LM73:
 419 0124 80E8      		ldi r24,lo8(-128)
 420 0126 00C0      		rjmp .L14
 422               	.Lscope6:
 426               	.global	LCD_WriteString
 428               	LCD_WriteString:
 146:src/LCDmodule.c ****   return;
 147:src/LCDmodule.c **** }
 148:src/LCDmodule.c **** 
 149:src/LCDmodule.c **** void LCD_WriteString(char *String)
 150:src/LCDmodule.c **** /* Displays a string of characters. End of string character is 0x00. */
 151:src/LCDmodule.c **** {
 430               	.LM74:
 431               	.LFBB7:
 432 0128 CF93      		push r28
 433 012a DF93      		push r29
 434               	/* prologue: function */
 435               	/* frame size = 0 */
 436               	/* stack size = 2 */
 437               	.L__stack_usage = 2
 438 012c EC01      		movw r28,r24
 439               	.L17:
 152:src/LCDmodule.c ****   char  *pChar;
 153:src/LCDmodule.c **** 
 154:src/LCDmodule.c ****   pChar = String;
 155:src/LCDmodule.c ****   while (*pChar != 0x00)
 441               	.LM75:
 442 012e 8991      		ld r24,Y+
 444               	.LM76:
 445 0130 8111      		cpse r24,__zero_reg__
 446 0132 00C0      		rjmp .L18
 447               	/* epilogue start */
 156:src/LCDmodule.c ****   { LCD_WriteData(*pChar);
 157:src/LCDmodule.c ****     pChar ++;
 158:src/LCDmodule.c ****   }
 159:src/LCDmodule.c ****   return;
 160:src/LCDmodule.c **** }
 449               	.LM77:
 450 0134 DF91      		pop r29
 451 0136 CF91      		pop r28
 452 0138 0895      		ret
 453               	.L18:
 156:src/LCDmodule.c ****   { LCD_WriteData(*pChar);
 455               	.LM78:
 456 013a 0E94 0000 		call LCD_WriteData
 457 013e 00C0      		rjmp .L17
 459               	.Lscope7:
 460               	.global	LCD_MarkBit
 461               		.section .bss
 464               	LCD_MarkBit:
 465 0000 00        		.zero	1
 467               		.text
 469               	.Letext0:
 470               		.ident	"GCC: (GNU) 11.2.0"
 471               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 LCDmodule.c
     /tmp/ccOS7KUV.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccOS7KUV.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccOS7KUV.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccOS7KUV.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccOS7KUV.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccOS7KUV.s:17     .text:0000000000000000 LCD_SetMarker
     /tmp/ccOS7KUV.s:464    .bss:0000000000000000 LCD_MarkBit
     /tmp/ccOS7KUV.s:49     .text:0000000000000014 LCD_WriteInst
     /tmp/ccOS7KUV.s:148    .text:0000000000000054 LCD_WriteData
     /tmp/ccOS7KUV.s:256    .text:000000000000009e LCD_Clear
     /tmp/ccOS7KUV.s:313    .text:00000000000000c4 LCD_Init
     /tmp/ccOS7KUV.s:390    .text:0000000000000114 LCD_MoveCursor
     /tmp/ccOS7KUV.s:428    .text:0000000000000128 LCD_WriteString

UNDEFINED SYMBOLS
__do_clear_bss
